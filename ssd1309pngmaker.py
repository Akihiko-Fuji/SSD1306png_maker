"""SSD1306/SSD1309 128x64 monochrome image optimiser.

このスクリプトは指定したディレクトリ内の画像をOLEDコントローラ
SSD1306/SSD1309向けに最適化された1bitデータへ変換します。
"""

from __future__ import annotations

import argparse
import re
import textwrap
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Dict, Iterable, List, Sequence

from PIL import Image, ImageOps
from tqdm import tqdm

# ==== デフォルト設定 ====
DEFAULT_RESAMPLE = "LANCZOS"
DEFAULT_MODE = "letterbox"  # or "stretch"
DEFAULT_DITHER = "FLOYDSTEINBERG"  # or "NONE"
DEFAULT_THRESHOLD = 128
DEFAULT_BGCOLOR = "black"  # or "white"
DEFAULT_OUTPUT_DIR = Path("output")
TARGET_SIZE = (128, 64)


class OutputFormat(str, Enum):
    """保存形式の種別"""

    PNG = "png"
    RAW = "raw"
    C_HEADER = "header"


RESAMPLE_MAP: Dict[str, int] = {
    "NEAREST": Image.NEAREST,
    "BILINEAR": Image.BILINEAR,
    "BICUBIC": Image.BICUBIC,
    "LANCZOS": Image.LANCZOS,
}

DITHER_MAP: Dict[str, int] = {
    "NONE": Image.NONE,
    "FLOYDSTEINBERG": Image.FLOYDSTEINBERG,
}

COLOR_MAP: Dict[str, int] = {
    "black": 0,
    "white": 255,
}

SUPPORTED_EXTENSIONS = (".png", ".jpg", ".jpeg", ".gif", ".bmp")


@dataclass
class ConversionConfig:
    """変換パラメータをまとめたデータクラス。"""

    mode: str
    resample: str
    dither: str
    threshold: int
    bgcolor: str
    allow_upscale: bool
    invert: bool
    output_formats: Sequence[OutputFormat]
    c_symbol_prefix: str


def get_unique_output_dir(base_dir: Path) -> Path:
    """output, output-02, output-03...のように枝番をつけてディレクトリを生成"""

    if not base_dir.exists():
        base_dir.mkdir(parents=True)
        return base_dir

    idx = 2
    while True:
        new_dir = Path(f"{base_dir}-{idx:02d}")
        if not new_dir.exists():
            new_dir.mkdir(parents=True)
            return new_dir
        idx += 1


def ensure_output_dir(output: Path | None, unique_base: Path = DEFAULT_OUTPUT_DIR) -> Path:
    """出力ディレクトリを作成して返す。"""

    if output:
        output.mkdir(parents=True, exist_ok=True)
        return output
    return get_unique_output_dir(unique_base)


def letterbox(img: Image.Image, target_size: Sequence[int], resample: int, bgcolor: int = 0) -> Image.Image:
    """長辺合わせ＋余白塗りで縦横比を維持しつつリサイズする。"""

    target_w, target_h = target_size
    ratio = min(target_w / img.width, target_h / img.height)
    new_w = max(1, int(img.width * ratio))
    new_h = max(1, int(img.height * ratio))
    img = img.resize((new_w, new_h), resample)

    new_img = Image.new("L", target_size, bgcolor)
    paste_x = (target_w - new_w) // 2
    paste_y = (target_h - new_h) // 2
    new_img.paste(img, (paste_x, paste_y))
    return new_img


def collect_image_files(input_dir: Path, recursive: bool) -> List[Path]:
    """入力ディレクトリから対象ファイル一覧を取得する。"""

    files: List[Path] = []
    if recursive:
        iterator: Iterable[Path] = input_dir.rglob("*")
    else:
        iterator = input_dir.glob("*")

    for path in iterator:
        if path.is_file() and path.suffix.lower() in SUPPORTED_EXTENSIONS:
            files.append(path)

    return sorted(files)


def sanitize_symbol_name(name: str) -> str:
    """C言語用の識別子に変換する。"""

    name = re.sub(r"[^0-9a-zA-Z_]", "_", name)
    if not name:
        name = "image"
    if name[0].isdigit():
        name = f"_{name}"
    return name


def image_to_c_header(img: Image.Image, symbol: str) -> str:
    """C言語ヘッダーファイルの文字列を生成する。"""

    data = img.tobytes()
    width, height = img.size
    bytes_per_line = 12
    hex_lines = []
    for i in range(0, len(data), bytes_per_line):
        chunk = ", ".join(f"0x{b:02X}" for b in data[i : i + bytes_per_line])
        hex_lines.append(f"    {chunk}")

    body = ",\n".join(hex_lines)
    header = textwrap.dedent(
        f"""// Auto-generated by ssd1309pngmaker.py
#pragma once

#define {symbol.upper()}_WIDTH {width}
#define {symbol.upper()}_HEIGHT {height}

static const unsigned char {symbol}[] = {{
{body}
}};
"""
    ).strip()

    return header + "\n"


def convert_image(input_path: Path, output_dir: Path, config: ConversionConfig) -> str:
    """単一ファイルを変換し、結果ステータスを返す。"""

    try:
        with Image.open(input_path) as img:
            if img.format == "GIF":
                img.seek(0)

            width, height = img.size
            if (width < TARGET_SIZE[0] or height < TARGET_SIZE[1]) and not config.allow_upscale:
                return "skip"

            img_gray = img.convert("L")

            if config.mode == "stretch":
                img_gray = img_gray.resize(TARGET_SIZE, RESAMPLE_MAP[config.resample])
            else:
                img_gray = letterbox(
                    img_gray,
                    TARGET_SIZE,
                    RESAMPLE_MAP[config.resample],
                    bgcolor=COLOR_MAP[config.bgcolor],
                )

            if config.dither == "NONE":
                img_bw = img_gray.point(lambda x: 255 if x > config.threshold else 0, mode="1")
            else:
                img_bw = img_gray.convert("1", dither=DITHER_MAP[config.dither])

            if config.invert:
                img_bw = ImageOps.invert(img_bw.convert("L")).convert("1")

            for fmt in config.output_formats:
                if fmt is OutputFormat.PNG:
                    out_path = output_dir / f"{input_path.stem}_128x64_bw.png"
                    img_bw.save(out_path, format="PNG")
                elif fmt is OutputFormat.RAW:
                    out_path = output_dir / f"{input_path.stem}_128x64_bw.raw"
                    out_path.write_bytes(img_bw.tobytes())
                elif fmt is OutputFormat.C_HEADER:
                    symbol = sanitize_symbol_name(f"{config.c_symbol_prefix}{input_path.stem}")
                    header_text = image_to_c_header(img_bw, symbol)
                    out_path = output_dir / f"{input_path.stem}_128x64_bw.h"
                    out_path.write_text(header_text, encoding="utf-8")

            return "success"

    except Exception as exc:  # pragma: no cover - safety net
        print(f"⚠️ {input_path.name} の処理に失敗: {exc}")
        return "fail"

    return "skip"


def parse_args() -> argparse.Namespace:
    """CLI引数の定義と取得。"""

    parser = argparse.ArgumentParser(description="128x64 1bit image converter")
    parser.add_argument("--input", required=True, help="入力ディレクトリ")
    parser.add_argument("--output", help="出力ディレクトリ。未指定時はoutput以下に枝番作成")
    parser.add_argument("--recursive", action="store_true", help="サブディレクトリも再帰的に探索")
    parser.add_argument("--mode", choices=["letterbox", "stretch"], default=DEFAULT_MODE)
    parser.add_argument("--resample", choices=RESAMPLE_MAP.keys(), default=DEFAULT_RESAMPLE)
    parser.add_argument("--dither", choices=DITHER_MAP.keys(), default=DEFAULT_DITHER)
    parser.add_argument("--threshold", type=int, default=DEFAULT_THRESHOLD, help="2値化のしきい値 (0-255)")
    parser.add_argument("--bgcolor", choices=COLOR_MAP.keys(), default=DEFAULT_BGCOLOR)
    parser.add_argument("--allow-upscale", action="store_true", help="小さな画像も128x64へ拡大して処理")
    parser.add_argument("--invert", action="store_true", help="白黒を反転して出力")
    parser.add_argument(
        "--output-format",
        choices=[fmt.value for fmt in OutputFormat],
        default=[OutputFormat.PNG.value],
        nargs="+",
        help="出力形式 (複数指定可)",
    )
    parser.add_argument(
        "--c-symbol-prefix",
        default="img_",
        help="ヘッダー出力時のシンボル名プレフィックス",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    input_dir = Path(args.input)
    if not input_dir.exists():
        print(f"❌ 入力ディレクトリが見つかりません: {input_dir}")
        return

    output_dir = ensure_output_dir(Path(args.output) if args.output else None)
    print(f"📁 出力先: {output_dir.resolve()}")

    files = collect_image_files(input_dir, recursive=args.recursive)
    if not files:
        print("⚠️ 対象ファイルが見つかりません。")
        return

    config = ConversionConfig(
        mode=args.mode,
        resample=args.resample,
        dither=args.dither,
        threshold=args.threshold,
        bgcolor=args.bgcolor,
        allow_upscale=args.allow_upscale,
        invert=args.invert,
        output_formats=[OutputFormat(fmt) for fmt in args.output_format],
        c_symbol_prefix=args.c_symbol_prefix,
    )

    stats = {"success": 0, "fail": 0, "skip": 0}
    for file_path in tqdm(files, desc="処理中", unit="file"):
        status = convert_image(file_path, output_dir, config)
        stats[status] += 1

    total = len(files)
    print("\n✅ 処理完了")
    print(f"   総ファイル数: {total}")
    print(f"   成功:       {stats['success']}")
    print(f"   スキップ:   {stats['skip']}")
    print(f"   失敗:       {stats['fail']}")


if __name__ == "__main__":
    main()
