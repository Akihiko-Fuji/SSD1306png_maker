"""SSD1306/SSD1309 128x64 monochrome image optimiser.

ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯æŒ‡å®šã—ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®ç”»åƒã‚’OLEDã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©
SSD1306/SSD1309å‘ã‘ã«æœ€é©åŒ–ã•ã‚ŒãŸ1bitãƒ‡ãƒ¼ã‚¿ã¸å¤‰æ›ã—ã¾ã™ã€‚
"""

from __future__ import annotations

import argparse
import re
import textwrap
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Dict, Iterable, List, Sequence

from PIL import Image, ImageOps
from tqdm import tqdm

# ==== ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š ====
DEFAULT_RESAMPLE = "LANCZOS"
DEFAULT_MODE = "letterbox"  # or "stretch"
DEFAULT_DITHER = "FLOYDSTEINBERG"  # or "NONE"
DEFAULT_THRESHOLD = 128
DEFAULT_BGCOLOR = "black"  # or "white"
DEFAULT_OUTPUT_DIR = Path("output")
TARGET_SIZE = (128, 64)


class OutputFormat(str, Enum):
    """ä¿å­˜å½¢å¼ã®ç¨®åˆ¥"""

    PNG = "png"
    RAW = "raw"
    C_HEADER = "header"


RESAMPLE_MAP: Dict[str, int] = {
    "NEAREST": Image.NEAREST,
    "BILINEAR": Image.BILINEAR,
    "BICUBIC": Image.BICUBIC,
    "LANCZOS": Image.LANCZOS,
}

DITHER_MAP: Dict[str, int] = {
    "NONE": Image.NONE,
    "FLOYDSTEINBERG": Image.FLOYDSTEINBERG,
}

COLOR_MAP: Dict[str, int] = {
    "black": 0,
    "white": 255,
}

SUPPORTED_EXTENSIONS = (".png", ".jpg", ".jpeg", ".gif", ".bmp")


@dataclass
class ConversionConfig:
    """å¤‰æ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã¾ã¨ã‚ãŸãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã€‚"""

    mode: str
    resample: str
    dither: str
    threshold: int
    bgcolor: str
    allow_upscale: bool
    invert: bool
    output_formats: Sequence[OutputFormat]
    c_symbol_prefix: str


def get_unique_output_dir(base_dir: Path) -> Path:
    """output, output-02, output-03...ã®ã‚ˆã†ã«æç•ªã‚’ã¤ã‘ã¦ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ç”Ÿæˆ"""

    if not base_dir.exists():
        base_dir.mkdir(parents=True)
        return base_dir

    idx = 2
    while True:
        new_dir = Path(f"{base_dir}-{idx:02d}")
        if not new_dir.exists():
            new_dir.mkdir(parents=True)
            return new_dir
        idx += 1


def ensure_output_dir(output: Path | None, unique_base: Path = DEFAULT_OUTPUT_DIR) -> Path:
    """å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã—ã¦è¿”ã™ã€‚"""

    if output:
        output.mkdir(parents=True, exist_ok=True)
        return output
    return get_unique_output_dir(unique_base)


def letterbox(img: Image.Image, target_size: Sequence[int], resample: int, bgcolor: int = 0) -> Image.Image:
    """é•·è¾ºåˆã‚ã›ï¼‹ä½™ç™½å¡—ã‚Šã§ç¸¦æ¨ªæ¯”ã‚’ç¶­æŒã—ã¤ã¤ãƒªã‚µã‚¤ã‚ºã™ã‚‹ã€‚"""

    target_w, target_h = target_size
    ratio = min(target_w / img.width, target_h / img.height)
    new_w = max(1, int(img.width * ratio))
    new_h = max(1, int(img.height * ratio))
    img = img.resize((new_w, new_h), resample)

    new_img = Image.new("L", target_size, bgcolor)
    paste_x = (target_w - new_w) // 2
    paste_y = (target_h - new_h) // 2
    new_img.paste(img, (paste_x, paste_y))
    return new_img


def collect_image_files(input_dir: Path, recursive: bool) -> List[Path]:
    """å…¥åŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’å–å¾—ã™ã‚‹ã€‚"""

    files: List[Path] = []
    if recursive:
        iterator: Iterable[Path] = input_dir.rglob("*")
    else:
        iterator = input_dir.glob("*")

    for path in iterator:
        if path.is_file() and path.suffix.lower() in SUPPORTED_EXTENSIONS:
            files.append(path)

    return sorted(files)


def sanitize_symbol_name(name: str) -> str:
    """Cè¨€èªç”¨ã®è­˜åˆ¥å­ã«å¤‰æ›ã™ã‚‹ã€‚"""

    name = re.sub(r"[^0-9a-zA-Z_]", "_", name)
    if not name:
        name = "image"
    if name[0].isdigit():
        name = f"_{name}"
    return name


def image_to_c_header(img: Image.Image, symbol: str) -> str:
    """Cè¨€èªãƒ˜ãƒƒãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã®æ–‡å­—åˆ—ã‚’ç”Ÿæˆã™ã‚‹ã€‚"""

    data = img.tobytes()
    width, height = img.size
    bytes_per_line = 12
    hex_lines = []
    for i in range(0, len(data), bytes_per_line):
        chunk = ", ".join(f"0x{b:02X}" for b in data[i : i + bytes_per_line])
        hex_lines.append(f"    {chunk}")

    body = ",\n".join(hex_lines)
    header = textwrap.dedent(
        f"""// Auto-generated by ssd1309pngmaker.py
#pragma once

#define {symbol.upper()}_WIDTH {width}
#define {symbol.upper()}_HEIGHT {height}

static const unsigned char {symbol}[] = {{
{body}
}};
"""
    ).strip()

    return header + "\n"


def convert_image(input_path: Path, output_dir: Path, config: ConversionConfig) -> str:
    """å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¤‰æ›ã—ã€çµæœã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¿”ã™ã€‚"""

    try:
        with Image.open(input_path) as img:
            if img.format == "GIF":
                img.seek(0)

            width, height = img.size
            if (width < TARGET_SIZE[0] or height < TARGET_SIZE[1]) and not config.allow_upscale:
                return "skip"

            img_gray = img.convert("L")

            if config.mode == "stretch":
                img_gray = img_gray.resize(TARGET_SIZE, RESAMPLE_MAP[config.resample])
            else:
                img_gray = letterbox(
                    img_gray,
                    TARGET_SIZE,
                    RESAMPLE_MAP[config.resample],
                    bgcolor=COLOR_MAP[config.bgcolor],
                )

            if config.dither == "NONE":
                img_bw = img_gray.point(lambda x: 255 if x > config.threshold else 0, mode="1")
            else:
                img_bw = img_gray.convert("1", dither=DITHER_MAP[config.dither])

            if config.invert:
                img_bw = ImageOps.invert(img_bw.convert("L")).convert("1")

            for fmt in config.output_formats:
                if fmt is OutputFormat.PNG:
                    out_path = output_dir / f"{input_path.stem}_128x64_bw.png"
                    img_bw.save(out_path, format="PNG")
                elif fmt is OutputFormat.RAW:
                    out_path = output_dir / f"{input_path.stem}_128x64_bw.raw"
                    out_path.write_bytes(img_bw.tobytes())
                elif fmt is OutputFormat.C_HEADER:
                    symbol = sanitize_symbol_name(f"{config.c_symbol_prefix}{input_path.stem}")
                    header_text = image_to_c_header(img_bw, symbol)
                    out_path = output_dir / f"{input_path.stem}_128x64_bw.h"
                    out_path.write_text(header_text, encoding="utf-8")

            return "success"

    except Exception as exc:  # pragma: no cover - safety net
        print(f"âš ï¸ {input_path.name} ã®å‡¦ç†ã«å¤±æ•—: {exc}")
        return "fail"

    return "skip"


def parse_args() -> argparse.Namespace:
    """CLIå¼•æ•°ã®å®šç¾©ã¨å–å¾—ã€‚"""

    parser = argparse.ArgumentParser(description="128x64 1bit image converter")
    parser.add_argument("--input", required=True, help="å…¥åŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª")
    parser.add_argument("--output", help="å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€‚æœªæŒ‡å®šæ™‚ã¯outputä»¥ä¸‹ã«æç•ªä½œæˆ")
    parser.add_argument("--recursive", action="store_true", help="ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚‚å†å¸°çš„ã«æ¢ç´¢")
    parser.add_argument("--mode", choices=["letterbox", "stretch"], default=DEFAULT_MODE)
    parser.add_argument("--resample", choices=RESAMPLE_MAP.keys(), default=DEFAULT_RESAMPLE)
    parser.add_argument("--dither", choices=DITHER_MAP.keys(), default=DEFAULT_DITHER)
    parser.add_argument("--threshold", type=int, default=DEFAULT_THRESHOLD, help="2å€¤åŒ–ã®ã—ãã„å€¤ (0-255)")
    parser.add_argument("--bgcolor", choices=COLOR_MAP.keys(), default=DEFAULT_BGCOLOR)
    parser.add_argument("--allow-upscale", action="store_true", help="å°ã•ãªç”»åƒã‚‚128x64ã¸æ‹¡å¤§ã—ã¦å‡¦ç†")
    parser.add_argument("--invert", action="store_true", help="ç™½é»’ã‚’åè»¢ã—ã¦å‡ºåŠ›")
    parser.add_argument(
        "--output-format",
        choices=[fmt.value for fmt in OutputFormat],
        default=[OutputFormat.PNG.value],
        nargs="+",
        help="å‡ºåŠ›å½¢å¼ (è¤‡æ•°æŒ‡å®šå¯)",
    )
    parser.add_argument(
        "--c-symbol-prefix",
        default="img_",
        help="ãƒ˜ãƒƒãƒ€ãƒ¼å‡ºåŠ›æ™‚ã®ã‚·ãƒ³ãƒœãƒ«åãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    input_dir = Path(args.input)
    if not input_dir.exists():
        print(f"âŒ å…¥åŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {input_dir}")
        return

    output_dir = ensure_output_dir(Path(args.output) if args.output else None)
    print(f"ğŸ“ å‡ºåŠ›å…ˆ: {output_dir.resolve()}")

    files = collect_image_files(input_dir, recursive=args.recursive)
    if not files:
        print("âš ï¸ å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚")
        return

    config = ConversionConfig(
        mode=args.mode,
        resample=args.resample,
        dither=args.dither,
        threshold=args.threshold,
        bgcolor=args.bgcolor,
        allow_upscale=args.allow_upscale,
        invert=args.invert,
        output_formats=[OutputFormat(fmt) for fmt in args.output_format],
        c_symbol_prefix=args.c_symbol_prefix,
    )

    stats = {"success": 0, "fail": 0, "skip": 0}
    for file_path in tqdm(files, desc="å‡¦ç†ä¸­", unit="file"):
        status = convert_image(file_path, output_dir, config)
        stats[status] += 1

    total = len(files)
    print("\nâœ… å‡¦ç†å®Œäº†")
    print(f"   ç·ãƒ•ã‚¡ã‚¤ãƒ«æ•°: {total}")
    print(f"   æˆåŠŸ:       {stats['success']}")
    print(f"   ã‚¹ã‚­ãƒƒãƒ—:   {stats['skip']}")
    print(f"   å¤±æ•—:       {stats['fail']}")


if __name__ == "__main__":
    main()
